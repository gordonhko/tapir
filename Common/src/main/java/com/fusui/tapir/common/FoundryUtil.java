package com.fusui.tapir.common;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.fusui.tapir.common.dto.FoundryConstants;
import com.fusui.tapir.common.dto.VoExpNode;
import com.fusui.tapir.common.dto.VoMetaOperand;
import com.fusui.tapir.common.dto.VoMetaOperator;
import com.fusui.tapir.common.dto.VoMetaOperator.VoOperatorMetaList;

public class FoundryUtil {

	// **********************************************************************
	// VoRule and VoExpNode
	// **********************************************************************
	public static VoExpNode buildExpressionTree(List<VoExpNode> nodeList) throws TapirException {
		// build tree from a list
		// can be optimized by combining two for loops

		VoExpNode rootNode = null;
		Map<String, VoExpNode> map = new HashMap<String, VoExpNode>();
		for (VoExpNode node : nodeList) {
			node.setChildList(null);
			String nid = node.getNodeId();
			map.put(nid, node);
		}

		for (VoExpNode node : nodeList) {
			String pid = node.getParentId();

			if (pid.equals(FoundryConstants.RULE_NODE_ROOT_ID)) {
				rootNode = node;
				continue;
			}

			VoExpNode pNode = map.get(pid);
			if (null == pNode) {
				throw new TapirException("cannot build tree since parent node is not available parentId=" + pid);
			}

			List<VoExpNode> list = pNode.getChildList();

			// the child is added without order, it will up to caller to decide
			// which node is in order.
			// in general, the child node in the left will have a smaller node
			// id (generated by sequence number). This is done by
			// FIND_EXPNODES_BY_RULE_SQL at DaoExpNode.java
			list.add(node);
		}

		if (null == rootNode) {
			throw new TapirException("cannot build tree since root node is not found");
		}

		return rootNode;
	}

	public static boolean isLogicalOp(String operator) {
		return operator.equalsIgnoreCase(FoundryConstants.RULE_OPERATOR_AND) || operator.equalsIgnoreCase(FoundryConstants.RULE_OPERATOR_OR) || operator.equalsIgnoreCase(FoundryConstants.RULE_OPERATOR_NOT);
	}

	// ***************************************************************************************
	// key for Map<String, VoAttributeMeta> converted from
	// VoDictionary.attrList.
	// where key String is attr name and result is VoAttributeMeta
	// ***************************************************************************************

	public static Map<String, VoMetaOperand> buildAttributeMetaMap(List<VoMetaOperand> attrList) {
		Map<String, VoMetaOperand> map = new HashMap<String, VoMetaOperand>();
		for (VoMetaOperand attr : attrList) {
			map.put(attr.getAttrName(), attr);
		}
		return map;
	}

	// ***************************************************************************************
	// key for Map<String, VoOperatorMetaList> defined at VoDictionary.operMap.
	// where key String is attr value type + selectionType and the result is a
	// list of VoOperatorMeta
	// ***************************************************************************************

	// This is for UI
	// Use this key to get a list of VoAttributeOperator
	// VS
	// V = valueType
	// S = selectionType
	public static String createOperatorKeyByVS(VoMetaOperator op) {
		return op.getValueType() + "." + op.getSelectionType();
	}

	public static String createOperatorKeyByVS(VoMetaOperand attr) {
		return attr.getValueType() + "." + attr.getSelectionType();
	}

	// ***************************************************************************************
	// create Map<String, VoOperatorMeta> where key String is attr value type +
	// selectionType + attr name
	// ***************************************************************************************
	// This is for UI
	// Use this key to get a single VoAttributeOperator
	// VSN
	// V = valueType
	// S = selectionType
	// N = operatorName
	public static Map<String, VoMetaOperator> buildOperatorMapByVSN(Map<String, VoOperatorMetaList> listMap) {
		Map<String, VoMetaOperator> map = new HashMap<String, VoMetaOperator>();
		for (Map.Entry<String, VoOperatorMetaList> entry : listMap.entrySet()) {
			for (VoMetaOperator op : entry.getValue().getList()) {

				// each op will be referenced by 2 keys - operatorName and
				// operatorUIName
				String key1 = createOperatorKeyByVSN(op.getValueType(), op.getSelectionType(), op.getOperatorName());
				map.put(key1, op);

				String key2 = createOperatorKeyByVSN(op.getValueType(), op.getSelectionType(), op.getOperatorUIName());
				if (!key2.equals(key1)) {
					map.put(key2, op);
				}
			}
		}
		return map;
	}

	public static String createOperatorKeyByVSN(String valueType, String selectionType, String opName) {
		return valueType + "." + selectionType + "." + opName;
	}

	// ***************************************************************************************
	// create Map<String, VoOperatorMeta> where key String is attr value type +
	// attr name
	// ***************************************************************************************
	// This is for ExpNode only to verify the validated operator
	// Use this key to get a single VoAttributeOperator
	// VN
	// V = valueType
	// N = operatorName

	private static void addOperatorByVN(String key, VoMetaOperator op, Map<String, VoMetaOperator> map) throws TapirException {
		VoMetaOperator existingOp = map.get(key);
		if (null != existingOp) {
			// make sure class name and method name are the same so that we can
			// override it
			if (existingOp.getClassName().equals(op.getClassName()) && existingOp.getMethodName().equals(op.getMethodName())) {
				// this is good. Do nothing
			} else {
				String msg = String.format("key=%s, old class=%s, new class=%s,  old method=%s, new method=%s\n", key, existingOp.getClassName(), op.getClassName(), existingOp.getMethodName(),
						op.getMethodName());
				throw new TapirException("Error : Different selection type that has same value type and operator name should share same class and method names\n " + msg);
			}
		} else {
			map.put(key, op);
		}
	}

	public static Map<String, VoMetaOperator> buildOperatorMapByVN(Map<String, VoOperatorMetaList> listMap) throws TapirException {
		Map<String, VoMetaOperator> map = new HashMap<String, VoMetaOperator>();
		for (Map.Entry<String, VoOperatorMetaList> entry : listMap.entrySet()) {
			for (VoMetaOperator op : entry.getValue().getList()) {
				String key = createOperatorKeyByVN(op.getValueType(), op.getOperatorName());
				addOperatorByVN(key, op, map);

				// UI name the second
				key = createOperatorKeyByVN(op.getValueType(), op.getOperatorUIName());
				addOperatorByVN(key, op, map);
			}
		}
		return map;
	}

	public static String createOperatorKeyByVN(String valueType, String opName) {
		return valueType + "." + opName;
	}

	// **********************************************************************
	// General String Functions
	// **********************************************************************

	public static boolean isEmpty(String str) {
		return str == null || str.length() == 0;
	}

	public static String[] split(String src, String delimiter) {
		if (src == null) {
			return new String[0];
		}

		int max = (src.length() / delimiter.length()) + 2; // one more for the
															// last
		int[] positions = new int[max];
		int dLen = delimiter.length();

		int i, j = 0;
		int count = 0;
		positions[0] = -dLen;
		while ((i = src.indexOf(delimiter, j)) != -1) {
			count++;
			positions[count] = i;
			j = i + dLen;
		}
		count++;
		positions[count] = src.length();
		String[] result = new String[count];

		for (i = 0; i < count; i++) {
			result[i] = src.substring(positions[i] + dLen, positions[i + 1]);
			result[i] = result[i].trim();
		}
		return result;
	}

	public static boolean isAnyActionIn(String sActions, String tActions) {
		String[] tActionArray = FoundryUtil.split(tActions, FoundryConstants.VALUE_DELIMITER);
		String[] sActionArray = FoundryUtil.split(sActions, FoundryConstants.VALUE_DELIMITER);

		for (String sAct : sActionArray) {
			for (String tAct : tActionArray) {
				if (sAct.equals(tAct)) {
					return true;
				}
			}
		}
		return false;
	}

	public static String getMD5Digest(String value) throws NoSuchAlgorithmException {

		MessageDigest md = MessageDigest.getInstance("MD5");
		md.reset();
		md.update(value.getBytes());

		byte mdBytes[] = md.digest();
		StringBuffer hexString = new StringBuffer();
		for (int i = 0; i < mdBytes.length; i++) {
			String hex = Integer.toHexString(0xff & mdBytes[i]);
			if (hex.length() == 1) {
				hexString.append('0');
			}
			hexString.append(hex);
		}
		return hexString.toString();

	}

	static public String sqlFilterVarchar(String s1) {
		StringBuilder s2 = new StringBuilder();
		if (s1 == null)
			s1 = "";
		int i = s1.length();
		String quo = "'";
		String quos = "''";
		for (int j = 0; j < i; j++) {
			if (s1.charAt(j) == quo.charAt(0)) {
				s2.append(quos);
				continue;
			}
			s2.append(s1.charAt(j));
		}
		String s3 = s2.toString();
		s3 = s3.replace("\0", "");
		return s3;
	}
	
	
	
	
	
	
	
	public static List<String> tokenize1(String src, byte delimiter) {
		
		final byte escape = '\\';
		if (src == null) {
			return null;
		}
		
		List <String >result = new ArrayList <String>();
		
		byte[] srcBytes = src.getBytes();
		int srcLen = srcBytes.length;
		byte[] destBytes = new byte[srcLen];
		
		int si = 0;
		int di = 0;
		
		while (true) {
			
			if (si >= srcLen ) {
				result.add (new String (destBytes).trim());
				break;
			}
			
			if ( srcBytes[si] == escape) {
				si++;
				if (si < srcLen ) {
					destBytes[di++]=srcBytes[si++];
				}
			}
			else if (srcBytes[si] == delimiter) {
				result.add (new String (destBytes).trim());
				Arrays.fill(destBytes, (byte)0);
				si++;		// skip over delimiter
				di = 0;
			}
			else {
				destBytes[di++] = srcBytes[si++];
			}
		}
		
//		for (String str : result) {
//			System.out.println(str);
//		}
		
		return result;
	}
	
	
	
	public static List<String> tokenize(String src, byte delimiter) {
		
				final byte escape = '\\';
		byte[] srcBytes = src.getBytes();
		if (srcBytes == null) {
			return null;
		}
		
		List <String >result = new ArrayList <String>();
		int srcLen = srcBytes.length;
		byte[] destBytes = new byte[srcLen];
		int si = 0;
		int di = 0;
		
		while (true) {
			
			if (si >= srcLen ) {
				byte[] token = new byte[di];
				System.arraycopy(destBytes, 0, token, 0, di);
				result.add (new String(token));
				break;
			}

			if (srcBytes[si] == escape) {
				si++;
				if (si < srcLen ) {
					destBytes[di++]=srcBytes[si++];
				}
			}
			else if (srcBytes[si] == delimiter) {
				byte[] token = new byte[di];
				System.arraycopy(destBytes, 0, token, 0, di);
				result.add (new String(token));
//				Arrays.fill(destBytes, (byte)0);
				si++;			// skip over delimiter
				di=0;			// reset start position
			}
			else {
				destBytes[di++]=srcBytes[si++];
			}
		}
		
//		System.out.println("--------------------->");
//		for (byte[] str : result) {
//			System.out.println(new String(str));
//		}
		return result;
	}
	
	
	
	
	
	
	
	
	

}
